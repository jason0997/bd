<div class="game-container flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-400 via-pink-500 to-red-500 p-4">
    <div class="bg-white p-6 rounded-lg shadow-xl max-w-lg w-full text-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-4 animate-bounce">
            ç”Ÿæ—¥å¿«ä¹ï¼ğŸ‰
        </h1>
        <div class="relative w-full max-w-md mx-auto aspect-video mb-6">
            <canvas id="birthdayCanvas" class="w-full h-full border-4 border-yellow-400 rounded-lg shadow-inner bg-blue-100"></canvas>
        </div>
        <p id="messageDisplay" class="text-xl font-semibold mb-6 text-gray-700">
            è¯·å°è¯•å¹ç­èœ¡çƒ›å§ï½
        </p>
    </div>

    <script>
        // Game state variables and constants
        const BLOW_THRESHOLD_FIXED = 50;
        const SAMPLE_SIZE = 128;

        const CAKE_BODY_COLOR = '#F5B041';
        const CAKE_SHADOW_COLOR = '#C38B27';
        const ICING_COLOR_TOP = '#FFD700';
        const ICING_COLOR_MIDDLE = '#FFC300';
        const CANDLE_COLOR_BASE = '#FF6F61';
        const CANDLE_COLOR_STRIPE = '#FFC0CB';
        const FLAME_COLOR_INNER = '#FFFF00';
        const FLAME_COLOR_OUTER = '#FF8C00';
        const WICK_COLOR = '#8B4513';
        const TABLE_COLOR = '#8B4513';

        // Variables for audio processing and game state
        let candlesLit = true;
        let isMicActive = false;
        let isGameEnded = false;
        let micAccessGranted = false;
        let audioContext = null;
        let analyser = null;
        let micStream = null;
        let animationFrameId = null;

        let canvas, ctx, messageDisplay;

        // Function to draw the cake
        function drawCake() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cakeHeight = canvas.height * 0.4;
            const cakeWidth = canvas.width * 0.7;
            const cakeX = (canvas.width - cakeWidth) / 2;
            const cakeY = canvas.height - cakeHeight - 20;

            // Draw table
            ctx.fillStyle = TABLE_COLOR;
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

            // Draw lower cake layer
            const lowerLayerHeight = cakeHeight / 2;
            ctx.fillStyle = CAKE_BODY_COLOR;
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + lowerLayerHeight, cakeWidth / 2, lowerLayerHeight * 0.25, 0, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.rect(cakeX, cakeY + lowerLayerHeight, cakeWidth, lowerLayerHeight * 0.8);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = ICING_COLOR_MIDDLE;
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + lowerLayerHeight, cakeWidth / 2, lowerLayerHeight * 0.25, 0, 0, 2 * Math.PI);
            ctx.fill();

            // Draw upper cake layer
            const topCakeWidth = cakeWidth * 0.8;
            const topCakeX = cakeX + (cakeWidth - topCakeWidth) / 2;
            const topCakeY = cakeY - lowerLayerHeight * 0.5; // Adjusted to be above the lower layer
            ctx.fillStyle = CAKE_BODY_COLOR;
            ctx.beginPath();
            ctx.ellipse(topCakeX + topCakeWidth / 2, topCakeY + lowerLayerHeight * 0.5, topCakeWidth / 2, lowerLayerHeight * 0.25, 0, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.rect(topCakeX, topCakeY + lowerLayerHeight * 0.5, topCakeWidth, lowerLayerHeight * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = ICING_COLOR_TOP;
            ctx.beginPath();
            ctx.ellipse(topCakeX + topCakeWidth / 2, topCakeY + lowerLayerHeight * 0.5, topCakeWidth / 2, lowerLayerHeight * 0.25, 0, 0, 2 * Math.PI);
            ctx.fill();

            // Draw shadows and details
            ctx.fillStyle = CAKE_SHADOW_COLOR;
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + cakeHeight + 5, cakeWidth / 2, cakeHeight * 0.05, 0, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Function to draw the candles
        function drawCandles() {
            const cakeWidth = canvas.width * 0.7;
            const topCakeWidth = cakeWidth * 0.8;
            const topCakeX = (canvas.width - topCakeWidth) / 2;
            const topCakeY = canvas.height * 0.6 - 20;
            const candleCount = 6;
            const candleWidth = topCakeWidth / (candleCount * 1.5);
            const candleHeight = canvas.height * 0.18;
            
            for (let i = 0; i < candleCount; i++) {
                const candleX = topCakeX + (i + 0.5) * (topCakeWidth / candleCount) - candleWidth / 2;
                const candleY = topCakeY - candleHeight + 10;
                
                // Draw candle body
                ctx.fillStyle = CANDLE_COLOR_BASE;
                ctx.fillRect(candleX, candleY, candleWidth, candleHeight);
                ctx.fillStyle = CANDLE_COLOR_STRIPE;
                for (let j = 0; j < 3; j++) {
                    ctx.fillRect(candleX, candleY + candleHeight / 4 + j * (candleHeight / 4), candleWidth, candleHeight / 10);
                }
                
                // Draw wick
                ctx.fillStyle = WICK_COLOR;
                ctx.fillRect(candleX + candleWidth / 2 - 1, candleY - 5, 2, 8);
                
                // Draw flame if candles are lit
                if (candlesLit) {
                    ctx.beginPath();
                    ctx.ellipse(candleX + candleWidth / 2, candleY - 12, candleWidth / 2.5, candleWidth * 0.7, 0, 0, 2 * Math.PI);
                    ctx.fillStyle = FLAME_COLOR_OUTER;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(candleX + candleWidth / 2, candleY - 12, candleWidth / 4, candleWidth * 0.4, 0, 0, 2 * Math.PI);
                    ctx.fillStyle = FLAME_COLOR_INNER;
                    ctx.fill();
                }
            }
        }

        // Main function to draw the entire scene
        function drawScene() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            drawCake();
            drawCandles();
        }

        // Stops the microphone stream and audio context
        function stopBlowing() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            if (audioContext) {
                if (audioContext.state !== 'closed') {
                    audioContext.close().catch(e => console.error("å…³é—­ AudioContext é”™è¯¯:", e));
                }
                audioContext = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            isMicActive = false;
        }

        // Analyzes the microphone audio for "blowing"
        function analyzeAudio() {
            if (!analyser || !candlesLit || isGameEnded) {
                // å¦‚æœæ¸¸æˆç»“æŸæˆ–èœ¡çƒ›å·²ç†„ç­ï¼Œåœæ­¢åˆ†æå¾ªç¯
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }
            
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < SAMPLE_SIZE; i++) {
                sum += dataArray[i];
            }
            const average = sum / SAMPLE_SIZE;
            
            if (average > BLOW_THRESHOLD_FIXED) {
                candlesLit = false;
                messageDisplay.textContent = "ç”Ÿæ—¥å¿«ä¹ï¼";
                messageDisplay.classList.add('text-green-600', 'animate-pulse');
                messageDisplay.classList.remove('text-gray-700');
                isGameEnded = true;
                stopBlowing();
                
                // Restore BGM volume
                if (bgm) {
                    bgm.volume = 1.0;
                }
                
                // Call the function from the parent window to show the modal
                if (window.showVictoryModal) {
                    window.showVictoryModal('ç”Ÿæ—¥å¿«ä¹ï¼<br>ç¥æ‚¨ç”Ÿæ—¥å¿«ä¹ï¼Œå¹¸ç¦å®‰åº·ï¼');
                }
            } else {
                animationFrameId = requestAnimationFrame(analyzeAudio);
            }
            drawScene();
        }

        // Starts the microphone access and audio analysis
        async function startBlowing() {
            if (isMicActive || isGameEnded) return;

            try {
                // Dim BGM volume before starting mic access
                if (bgm) {
                    bgm.volume = 0.2;
                }
                
                micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const source = audioContext.createMediaStreamSource(micStream);
                source.connect(analyser);

                isMicActive = true;
                micAccessGranted = true;
                messageDisplay.textContent = "è¯·å°è¯•å¹ç­èœ¡çƒ›ï¼";
                messageDisplay.classList.remove('text-green-600', 'animate-pulse');
                messageDisplay.classList.add('text-gray-700');
                
                animationFrameId = requestAnimationFrame(analyzeAudio);
            } catch (err) {
                console.error("è®¿é—®éº¦å…‹é£é”™è¯¯:", err);
                messageDisplay.textContent = "æ— æ³•è®¿é—®éº¦å…‹é£ã€‚è¯·æˆäºˆæƒé™ä»¥å¹ç­èœ¡çƒ›ã€‚";
                isMicActive = false;
                micAccessGranted = false;
                // Restore BGM volume on error
                if (bgm) {
                    bgm.volume = 1.0;
                }
            }
            drawScene();
        }

        // Global function to initialize this page, called from index.html
        window.initPage2 = function() {
            // Get DOM elements here to ensure they exist after content is loaded
            canvas = document.getElementById('birthdayCanvas');
            ctx = canvas.getContext('2d');
            messageDisplay = document.getElementById('messageDisplay');
            // Safely get the BGM element from the parent window

            // Set initial state
            candlesLit = true;
            isMicActive = false;
            isGameEnded = false;
            
            drawScene();
            startBlowing();
            
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
            window.removeEventListener('resize', drawScene);
            window.addEventListener('resize', drawScene);
        };
    </script>
</div>
