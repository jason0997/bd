<div class="game-container flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-400 via-pink-500 to-red-500 p-4">
    <div class="bg-white p-6 rounded-lg shadow-xl max-w-lg w-full text-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-4 animate-bounce">
            ç”Ÿæ—¥å¿«ä¹ï¼ğŸ‰
        </h1>
        <div class="relative w-full max-w-md mx-auto aspect-video mb-6">
            <canvas id="birthdayCanvas" class="w-full h-full border-4 border-yellow-400 rounded-lg shadow-inner bg-blue-100"></canvas>
        </div>
        <p id="messageDisplay" class="text-xl font-semibold mb-6 text-gray-700">
            è¯·å°è¯•å¹ç­èœ¡çƒ›å§ï½
        </p>
    </div>

    <script>
        const canvas = document.getElementById('birthdayCanvas');
        const ctx = canvas.getContext('2d');
        const messageDisplay = document.getElementById('messageDisplay');

        let candlesLit = true;
        let isMicActive = false;
        let isGameEnded = false;
        let micAccessGranted = false;
        let audioContext = null;
        let analyser = null;
        let micStream = null;
        let animationFrameId = null;
        let bgm=null;

        const BLOW_THRESHOLD_FIXED = 50;
        const SAMPLE_SIZE = 128;

        const CAKE_BODY_COLOR = '#F5B041';
        const CAKE_SHADOW_COLOR = '#C38B27';
        const ICING_COLOR_TOP = '#FFD700';
        const ICING_COLOR_MIDDLE = '#FFC300';
        const CANDLE_COLOR_BASE = '#FF6F61';
        const CANDLE_COLOR_STRIPE = '#FFC0CB';
        const FLAME_COLOR_INNER = '#FFFF00';
        const FLAME_COLOR_OUTER = '#FF8C00';
        const WICK_COLOR = '#8B4513';
        const TABLE_COLOR = '#8B4513';

        function drawCake(ctx, width, height) {
            ctx.clearRect(0, 0, width, height);
            const cakeHeight = height * 0.4;
            const cakeWidth = width * 0.7;
            const cakeX = (width - cakeWidth) / 2;
            const cakeY = height - cakeHeight - 20;
            ctx.fillStyle = TABLE_COLOR;
            ctx.fillRect(0, height - 50, width, 50);
            const layerHeight = cakeHeight / 2;
            ctx.fillStyle = CAKE_BODY_COLOR;
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + cakeHeight / 2 + layerHeight / 2, cakeWidth / 2, layerHeight / 2, 0, Math.PI, 2 * Math.PI, false);
            ctx.rect(cakeX, cakeY + cakeHeight / 2, cakeWidth, layerHeight);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = ICING_COLOR_MIDDLE;
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + cakeHeight / 2, cakeWidth / 2, layerHeight * 0.2, 0, 0, 2 * Math.PI);
            ctx.fill();
            const topCakeWidth = cakeWidth * 0.8;
            const topCakeX = cakeX + (cakeWidth - topCakeWidth) / 2;
            const topCakeY = cakeY;
            ctx.fillStyle = CAKE_BODY_COLOR;
            ctx.beginPath();
            ctx.ellipse(topCakeX + topCakeWidth / 2, topCakeY + layerHeight / 2, topCakeWidth / 2, layerHeight / 2, 0, Math.PI, 2 * Math.PI, false);
            ctx.rect(topCakeX, topCakeY, topCakeWidth, layerHeight);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = ICING_COLOR_TOP;
            ctx.beginPath();
            ctx.ellipse(topCakeX + topCakeWidth / 2, topCakeY + layerHeight / 2, topCakeWidth / 2, layerHeight * 0.2, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = CAKE_SHADOW_COLOR;
            ctx.beginPath();
            ctx.ellipse(cakeX + cakeWidth / 2, cakeY + cakeHeight + 5, cakeWidth / 2, cakeHeight * 0.05, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = ICING_COLOR_TOP;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= 20; i++) {
                const x = topCakeX + (topCakeWidth / 20) * i;
                const y = topCakeY + layerHeight / 2 + (i % 2 === 0 ? -5 : 5);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.beginPath();
            for (let i = 0; i <= 20; i++) {
                const x = cakeX + (cakeWidth / 20) * i;
                const y = cakeY + cakeHeight / 2 + (i % 2 === 0 ? -5 : 5);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawCandles(ctx, lit, width, height) {
            const cakeWidth = width * 0.7;
            const topCakeWidth = cakeWidth * 0.8;
            const topCakeX = (width - topCakeWidth) / 2;
            const topCakeY = height * 0.6 - 20;
            const candleCount = 6;
            const candleWidth = topCakeWidth / (candleCount * 1.5);
            const candleHeight = height * 0.18;
            for (let i = 0; i < candleCount; i++) {
                const candleX = topCakeX + (i + 0.5) * (topCakeWidth / candleCount) - candleWidth / 2;
                const candleY = topCakeY - candleHeight + 10;
                ctx.fillStyle = CANDLE_COLOR_BASE;
                ctx.fillRect(candleX, candleY, candleWidth, candleHeight);
                ctx.fillStyle = CANDLE_COLOR_STRIPE;
                for (let j = 0; j < 3; j++) {
                    ctx.fillRect(candleX, candleY + candleHeight / 4 + j * (candleHeight / 4), candleWidth, candleHeight / 10);
                }
                ctx.fillStyle = WICK_COLOR;
                ctx.fillRect(candleX + candleWidth / 2 - 1, candleY - 5, 2, 8);
                if (lit) {
                    ctx.beginPath();
                    ctx.ellipse(candleX + candleWidth / 2, candleY - 12, candleWidth / 2.5, candleWidth * 0.7, 0, 0, 2 * Math.PI);
                    ctx.fillStyle = FLAME_COLOR_OUTER;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(candleX + candleWidth / 2, candleY - 12, candleWidth / 4, candleWidth * 0.4, 0, 0, 2 * Math.PI);
                    ctx.fillStyle = FLAME_COLOR_INNER;
                    ctx.fill();
                }
            }
        }

        function drawScene() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            drawCake(ctx, rect.width, rect.height);
            drawCandles(ctx, candlesLit, rect.width, rect.height);
        }

        function stopBlowing() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            if (audioContext) {
                if (audioContext.state !== 'closed') {
                    audioContext.close().catch(e => console.error("å…³é—­ AudioContext é”™è¯¯:", e));
                }
                audioContext = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            isMicActive = false;
        }

        function analyzeAudio() {
            if (!analyser || !candlesLit || isGameEnded || !micAccessGranted) {
                animationFrameId = null;
                return;
            }
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < SAMPLE_SIZE; i++) {
                sum += dataArray[i];
            }
            const average = sum / SAMPLE_SIZE;
            if (average > 30) {
                bgm.volume = 1.0;
                candlesLit = false;
                messageDisplay.textContent = "ç”Ÿæ—¥å¿«ä¹ï¼";
                messageDisplay.classList.add('text-green-600', 'animate-pulse');
                messageDisplay.classList.remove('text-gray-700');
                isGameEnded = true;
                stopBlowing();
                window.showVictoryModal('ç”Ÿæ—¥å¿«ä¹ï¼<br>ç¥æ‚¨ç”Ÿæ—¥å¿«ä¹ï¼Œå¹¸ç¦å®‰åº·ï¼');
            } else {
                animationFrameId = requestAnimationFrame(analyzeAudio);
            }
            drawScene();
        }

        async function startBlowing() {
            if (isMicActive || (micAccessGranted && !isGameEnded)) return;
            try {
                                if(bgm) {
                    bgm.volume =0.2;
                }
                micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const source = audioContext.createMediaStreamSource(micStream);
                source.connect(analyser);
                isMicActive = true;
                micAccessGranted = true;
                messageDisplay.textContent = "è¯·å°è¯•å¹ç­èœ¡çƒ›ï¼";
                messageDisplay.classList.remove('text-green-600', 'animate-pulse');
                messageDisplay.classList.add('text-gray-700');
                animationFrameId = requestAnimationFrame(analyzeAudio);
            } catch (err) {
                console.error("è®¿é—®éº¦å…‹é£é”™è¯¯:", err);
                messageDisplay.textContent = "æ— æ³•è®¿é—®éº¦å…‹é£ã€‚è¯·æˆäºˆæƒé™ä»¥å¹ç­èœ¡çƒ›ã€‚";
                isMicActive = false;
                micAccessGranted = false;
            }
            drawScene();
        }

        function resetGameInternal() {
            stopBlowing();
            candlesLit = true;
            messageDisplay.textContent = "è¯·å°è¯•å¹ç­èœ¡çƒ›ï¼";
            messageDisplay.classList.remove('text-green-600', 'animate-pulse');
            messageDisplay.classList.add('text-gray-700');
            isGameEnded = false;
            if (!micAccessGranted) {
                startBlowing();
            } else {
                isMicActive = true;
                animationFrameId = requestAnimationFrame(analyzeAudio);
            }
            drawScene();
        }

        // ä¿®æ”¹æ­¤å¤„ï¼šå°†åˆå§‹åŒ–é€»è¾‘å°è£…åˆ°æ–°å‡½æ•°ä¸­
        window.initPage2 = function() {
            bgm = window.parent.document.getElementById('bgm');
            drawScene();
            startBlowing();
            window.addEventListener('resize', drawScene);
        };
    </script>
</div>
