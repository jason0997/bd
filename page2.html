<div class="game-container flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-400 via-pink-500 to-red-500 p-4">
    <div class="bg-white p-6 rounded-lg shadow-xl max-w-lg w-full text-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-4 animate-bounce">
            ÁîüÊó•Âø´‰πêÔºÅüéâ
        </h1>
        <div class="relative w-full max-w-md mx-auto aspect-video mb-6">
            <canvas id="birthdayCanvas" class="w-full h-full border-4 border-yellow-400 rounded-lg shadow-inner bg-blue-100"></canvas>
        </div>
        <p id="messageDisplay" class="text-xl font-semibold mb-6 text-gray-700">
            ËØ∑Â∞ùËØïÂêπÁÅ≠Ëú°ÁÉõÂêßÔΩû
        </p>
    </div>

    <script>
        // Game state variables and constants
        const BLOW_THRESHOLD_FIXED = 50;
        const SAMPLE_SIZE = 128;

        // Color Palette
        const PLATE_COLOR = '#FFD700'; // Yellow
        const CAKE_BODY_COLOR = '#FADADD'; // Light Pink
        const CAKE_TOP_COLOR = '#FFC0CB';   // Pink
        const CANDLE_COLOR = '#FF6F61';   // Coral Red
        const WICK_COLOR = '#5D4037';      // Dark Brown
        const FLAME_OUTER_COLOR = '#FFAB00'; // Orange
        const FLAME_INNER_COLOR = '#FFD600'; // Bright Yellow

        // Variables for audio processing and game state
        let candlesLit = true;
        let isMicActive = false;
        let isGameEnded = false;
        let audioContext = null;
        let analyser = null;
        let micStream = null;
        let animationFrameId = null;

        let canvas, ctx, messageDisplay;

        // --- NEW & IMPROVED DRAWING FUNCTION ---
        function drawScene() {
            // Setup canvas for high-DPI screens
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const canvasWidth = rect.width;
            const canvasHeight = rect.height;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Define central drawing coordinates
            const centerX = canvasWidth / 2;
            const baseY = canvasHeight * 0.85;

            // --- 1. Draw the Plate ---
            const plateWidth = canvasWidth * 0.8;
            const plateHeight = canvasHeight * 0.1;
            ctx.fillStyle = PLATE_COLOR;
            ctx.beginPath();
            ctx.ellipse(centerX, baseY, plateWidth / 2, plateHeight / 2, 0, 0, 2 * Math.PI);
            ctx.fill();

            // --- 2. Draw the Bottom Cake Layer ---
            const bottomLayerWidth = plateWidth * 0.8;
            const bottomLayerHeight = canvasHeight * 0.2;
            const bottomLayerY = baseY - bottomLayerHeight;
            // Body
            ctx.fillStyle = CAKE_BODY_COLOR;
            ctx.fillRect(centerX - bottomLayerWidth / 2, bottomLayerY, bottomLayerWidth, bottomLayerHeight);
            // Top Icing (for 3D effect)
            ctx.fillStyle = CAKE_TOP_COLOR;
            ctx.beginPath();
            ctx.ellipse(centerX, bottomLayerY, bottomLayerWidth / 2, plateHeight / 4, 0, 0, 2 * Math.PI);
            ctx.fill();

            // --- 3. Draw the Top Cake Layer ---
            const topLayerWidth = bottomLayerWidth * 0.75;
            const topLayerHeight = canvasHeight * 0.18;
            const topLayerY = bottomLayerY - topLayerHeight;
            // Body
            ctx.fillStyle = CAKE_BODY_COLOR;
            ctx.fillRect(centerX - topLayerWidth / 2, topLayerY, topLayerWidth, topLayerHeight);
            // Top Icing
            ctx.fillStyle = CAKE_TOP_COLOR;
            ctx.beginPath();
            ctx.ellipse(centerX, topLayerY, topLayerWidth / 2, plateHeight / 4, 0, 0, 2 * Math.PI);
            ctx.fill();

            // --- 4. Draw the Candles ---
            const candleCount = 3;
            const candleWidth = 15;
            const candleHeight = canvasHeight * 0.15;
            // Calculate even spacing for the candles on the top layer
            const candleSpacing = topLayerWidth / (candleCount + 1);
            const startX = centerX - topLayerWidth / 2 + candleSpacing;
            const candleY = topLayerY - candleHeight;

            for (let i = 0; i < candleCount; i++) {
                const x = startX + i * candleSpacing;
                
                // Candle Body
                ctx.fillStyle = CANDLE_COLOR;
                ctx.fillRect(x - candleWidth / 2, candleY, candleWidth, candleHeight);

                // Wick
                const wickX = x;
                const wickY = candleY;
                const wickHeight = 8;
                ctx.fillStyle = WICK_COLOR;
                ctx.fillRect(wickX - 1.5, wickY - wickHeight, 3, wickHeight);

                // Flame
                if (candlesLit) {
                    const flameBaseY = wickY - wickHeight;
                    const flameHeight = 30;
                    const flameWidth = 15;
                    
                    // Outer flame (teardrop shape)
                    ctx.fillStyle = FLAME_OUTER_COLOR;
                    ctx.beginPath();
                    ctx.moveTo(wickX, flameBaseY);
                    ctx.quadraticCurveTo(wickX + flameWidth, flameBaseY - flameHeight / 2, wickX, flameBaseY - flameHeight);
                    ctx.quadraticCurveTo(wickX - flameWidth, flameBaseY - flameHeight / 2, wickX, flameBaseY);
                    ctx.fill();

                    // Inner flame
                    ctx.fillStyle = FLAME_INNER_COLOR;
                    ctx.beginPath();
                    ctx.moveTo(wickX, flameBaseY);
                    ctx.quadraticCurveTo(wickX + flameWidth / 2, flameBaseY - flameHeight / 2.5, wickX, flameBaseY - flameHeight / 1.5);
                    ctx.quadraticCurveTo(wickX - flameWidth / 2, flameBaseY - flameHeight / 2.5, wickX, flameBaseY);
                    ctx.fill();
                }
            }
        }


        // Stops the microphone stream and audio context
        function stopBlowing() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.error("Error closing AudioContext:", e));
                audioContext = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            isMicActive = false;
        }

        // Analyzes the microphone audio for "blowing"
        function analyzeAudio() {
            if (!analyser || !candlesLit || isGameEnded) {
                stopBlowing();
                return;
            }

            animationFrameId = requestAnimationFrame(analyzeAudio);

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < SAMPLE_SIZE; i++) {
                sum += dataArray[i];
            }
            const average = sum / SAMPLE_SIZE;

            if (average > BLOW_THRESHOLD_FIXED) {
                candlesLit = false;
                isGameEnded = true;
                drawScene(); // Final redraw with candles extinguished
                
                messageDisplay.textContent = "ÁîüÊó•Âø´‰πêÔºÅ";
                messageDisplay.classList.add('text-green-600', 'animate-pulse');
                messageDisplay.classList.remove('text-gray-700');
                
                if (window.bgm) {
                    window.bgm.play();
                }

                if (window.showVictoryModal) {
                    setTimeout(() => {
                        window.showVictoryModal('ÁîüÊó•Âø´‰πêÔºÅ<br>Á•ùÊÇ®ÁîüÊó•Âø´‰πêÔºåÂπ∏Á¶èÂÆâÂ∫∑ÔºÅ');
                    }, 500); // Short delay before showing modal
                }
            }
        }

        // Starts the microphone access and audio analysis
        async function startBlowing() {
            if (isMicActive || isGameEnded) return;

            try {
                if (window.bgm) {
                    window.bgm.volume.pause();
                }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                micStream = stream;
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const source = audioContext.createMediaStreamSource(micStream);
                source.connect(analyser);
                isMicActive = true;
                analyzeAudio(); // Start the analysis loop
            } catch (err) {
                console.error("Error accessing microphone:", err);
                messageDisplay.textContent = "Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£é„ÄÇËØ∑Êéà‰∫àÊùÉÈôê„ÄÇ";
                if (window.bgm) {
                    window.bgm.play();
                }
            }
        }

        // Global function to initialize this page, called from index.html
        window.initPage2 = function() {
            canvas = document.getElementById('birthdayCanvas');
            ctx = canvas.getContext('2d');
            messageDisplay = document.getElementById('messageDisplay');

            // Set initial state
            candlesLit = true;
            isMicActive = false;
            isGameEnded = false;

            drawScene();
            startBlowing();


            window.removeEventListener('resize', drawScene);
            window.addEventListener('resize', drawScene);
        };
    </script>
</div>
